---
sidebar_position: 15
sidebar_label: Record IDs
title: Record IDs | SurrealQL
description: In SurrealDB, document record IDs store both the table name, and the record ID.

---

# Record IDs

> [!NOTE]
> As of `v2.0.0`, SurrealDB no longer eagerly converts a string into a record. An [implicit `r` prefix or cast](/docs/surrealql/datamodel/casting#casting-vs-affixes) is required instead.

In SurrealDB, document record IDs store both the table name and the record identifier. This allows for a simple and consistent way to reference records across the database. Record IDs are used to uniquely identify records within a table, to [query](/docs/surrealql/statements/select), [update](/docs/surrealql/statements/update), and [delete](/docs/surrealql/statements/delete) records, and serve as [links](/docs/surrealql/datamodel/records) from one record to another.

Record IDs are made up of two parts: the table name, and the record identifier. The table name is separated from the record identifier by a `:` character.

Record IDs can be constructed using a number of different types of values, including [built-in ID generation functions](/docs/surrealql/datamodel/ids#generating-record-ids), [alphanumeric text](/docs/surrealql/datamodel/ids#text-record-ids), complex Unicode text and symbols, [numbers](/docs/surrealql/datamodel/ids#numeric-record-ids), arrays, and objects. 

Some examples of record IDs are:

```surql
company:surrealdb
company:w6xb3izpgvz4n0gow6q7
reaction:`ü§™`
weather:['London', d'2025-02-14T01:52:50.375Z']
user:{ email: 'me@me.com', since: d'2025-02-14T01:54:46.920Z' }
```

{/* A record ID alone is enough to access its fields */}

As record IDs are immutable, it is important to choose the record ID that suits your purposes.

## Types of Record IDs

### Random IDs

When you [create a record](/docs/surrealql/statements/create) without specifying the full ID, a random id is assigned after the table name. This differs from the traditional default of auto-increment or serial IDs many developers are used to.

```surql
CREATE company;
```

```surql title="Output"
[
	{
		id: company:ezs644u19mae2p68404j
	}
]
```

Record IDs can be generated with a number of built-in ID generation functions. These allow for record IDs to be generated using cryptographically-secure randomly-generated identifiers (which are suitable for dispersion across a distributed datastore), sequentially incrementing `ULID` Record identifiers, and `UUID` version 7 Record identifiers.

```surql
// Generate a random record ID
// Charset: `abcdefghijklmnopqrstuvwxyz0123456789`
// ID Length: 20 characters long
CREATE temperature SET time = time::now(), celsius = 37.5;
// :rand() is the default random ID format, so this
// is identical to the above CREATE statement
CREATE temperature:rand() SET time = time::now(), celsius = 37.5;

// Generate a ULID-based record ID
CREATE temperature:ulid() SET time = time::now(), celsius = 37.5;
// Generate a UUIDv7-based record ID
CREATE temperature:uuid() SET time = time::now(), celsius = 37.5;
```

### Text Record IDs

Without annotation, text record IDs can contain letters, numbers and `_` characters.

```surql
CREATE company:surrealdb SET name = 'SurrealDB';
```

Record IDs can contain complex characters, surrounded by the <code>`</code>  character (a backtick).

```surql
CREATE article:`8424486b-85b3-4448-ac8d-5d51083391c7` SET
    time = time::now(),
    author = person:tobie;
```

Parts of Record IDs with complex characters will be enclosed by a `‚ü®` and `‚ü©`.

```surql title="Output"
[
	{
		author: person:tobie,
		id: article:‚ü®8424486b-85b3-4448-ac8d-5d51083391c7‚ü©,
		time: d'2025-02-14T02:14:46.979Z'
	}
]
```

As the `‚ü®` and `‚ü©` characters are used for the complex parts of a record ID, they can be used directly instead of backticks if preferred. Note: these characters are different from `<` and `>` found on standard keyboards.

```surql
CREATE ‚ü®üìñ‚ü© SET
    time = time::now(),
    author = person:tobie;
```

If you create a record ID with a number as a string, it will also be stored with the `‚ü® ‚ü©` characters to differentiate it from a number.

```surql
CREATE article SET id = 10;
CREATE article SET id = "10";
SELECT VALUE id FROM article;
```

```surql title="Output"
[
	article:10,
	article:‚ü®10‚ü©
]
```

### Numeric Record IDs
If a numeric value is specified without any decimal point suffix and is within the range `-9223372036854775808` to `9223372036854775807` then the value will be parsed, stored, and treated as a 64-bit signed integer.

If the numeric number is outside the range of a signed 64-bit integer it will be treated as a string.

```surql
CREATE temperature:17493 SET time = time::now(), celsius = 37.5;
```

### Array-based Record IDs

Similar to object-based record IDs, records in SurrealDB can store arrays of values, with no limit to the depth of the arrays. Arrays can store any value stored within them, and can store different value types within the same array. Retrieving records with RecordIDs which are object is the same as how it is done with RecordIDs which are arrays.

```surql
CREATE weather:['London', d'2025-02-13T05:00:00Z'] SET
    temperature = 5.7,
    conditions = "cloudy";

CREATE weather:['London', d'2025-02-13T06:00:00Z'] SET
    temperature = 5.3,
    conditions = "cloudy";

CREATE weather:['Seoul', d'2025-02-13T06:00:00Z'] SET
    temperature = -2.3,
    conditions = "cloudy";
```

### Object-based Record IDs
Complex record IDs support dynamic expressions, allowing parameters, and function expressions to be used as values within the IDs. This is useful in a timeseries context, or for ensuring locality between specific records in a table. All object keys in SurrealDB are sorted alphabetically

```surql
// Set a new parameter
LET $now = time::now();
// Create a record with a complex ID using an object
CREATE temperature:{ location: 'London', date: $now } SET
	location = 'London',
	date = $now,
	temperature = 23.7
;
```

### Record ranges
SurrealDB supports the ability to query a range of records, using the record ID. The record ID ranges, retrieve records using the natural sorting order of the record IDs. These range queries can be used to query a range of records in a timeseries context.

```surql
-- Select all person records with IDs between the given range
SELECT * FROM person:1..1000;
-- Select all records for a particular location, inclusive
SELECT * FROM temperature:['London', NONE]..=['London', ..];
-- Select all temperature records with IDs less than a maximum value
SELECT * FROM temperature:..['London', '2022-08-29T08:09:31'];
-- Select all temperature records with IDs greater than a minimum value
SELECT * FROM temperature:['London', '2022-08-29T08:03:39']..;
-- Select all temperature records with IDs between the specified range
SELECT * FROM temperature:['London', '2022-08-29T08:03:39']..['London', '2022-08-29T08:09:31'];
```

## Points to keep in mind when choosing a record ID format

### Meaningful sortable IDs are faster to query

Records are returned in ascending record ID order by default. As the following query shows, a `SELECT` statement on a large number of `user` records with random IDs will show those with record identifiers starting with a large number of zeroes.

```surql
CREATE |user:200000| RETURN NONE;
SELECT VALUE id FROM user LIMIT 4;
```

```surql title="Output"
[
	user:0001th0nnywnczi7mrvk,
	user:000t5r3y7u8stqtecvht,
	user:000tjk1nbi1it1bedplc,
	user:001dfral92ltbdznypcd
]
```

For a large number of records, pagination can be used to retrieve a certain amount of records at a time.

```surql
-- Returns the same four records as above
SELECT VALUE id FROM user START 0 LIMIT 2;
SELECT VALUE id FROM user START 2 LIMIT 2;
```

```surql title="Output"
-------- Query --------

[
	user:0001th0nnywnczi7mrvk,
	user:000t5r3y7u8stqtecvht
]

-------- Query --------

[
	user:001dfral92ltbdznypcd,
	user:001hv9g1uzh32nophrpo
]
```

As record ranges are very performant, consider moving any fields that may be used in a `WHERE` clause into the ID itself.

In the following example, a number of `user` records are created using the default random ID, plus a `num` field that tracks in which order the user was created.

```surql
FOR $num IN 0..100 {
    CREATE user SET num = $num;
    sleep(1ms); -- Simulate a bit of time between user creation
};

SELECT * FROM user WHERE num IN 50..=51;
SELECT * FROM user START 50 LIMIT 2;
```

As the output from the `SELECT` statements show, a `WHERE` clause is needed to find two users starting at a `num` of 50, as `START 50` starts based on the user of the record ID, which is entirely random.

```surql
-------- Query --------

[
	{
		id: user:pqpeg0edt8kpda907o01,
		num: 50
	},
	{
		id: user:ty6qr7zyob5dh882it08,
		num: 51
	}
]

-------- Query --------

[
	{
		id: user:hvfp5m5ty7n2k95dbamv,
		num: 70
	},
	{
		id: user:hvfumcmmveuolg4e2h26,
		num: 36
	}
]
```

Using a `ULID` in this case will allow the IDs to remain random, but still sorted by date of creation.

```surql
FOR $num IN 0..100 {
    CREATE user:ulid() SET num = $num;
    sleep(1ms);
};

SELECT * FROM user WHERE num IN 50..=51;
SELECT * FROM user START 50 LIMIT 2;
```

Not only is the `START 50 LIMIT 2` query more performant, but the entire `num` field could be removed if its only use is to return records by order of creation.

```surql title="Same record IDs for both queries this time"
-------- Query --------

[
	{
		id: user:01JM1AHN7DDN7XM5KZ2RR2YM1S,
		num: 50
	},
	{
		id: user:01JM1AHN7FS4A3B6RNFCF64H90,
		num: 51
	}
]

-------- Query --------

[
	{
		id: user:01JM1AHN7DDN7XM5KZ2RR2YM1S,
		num: 50
	},
	{
		id: user:01JM1AHN7FS4A3B6RNFCF64H90,
		num: 51
	}
]
```

## Limitations

At present, definitions for a record ID's value inside a [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statement are ignored.

```surql
DEFINE FIELD id ON user VALUE rand::int(1, 1000000000) READONLY;
CREATE user;
```

```surql title="Output"
[
	{
		id: user:9ixn3oei6o532c2qyixa
	}
]
```

However, the `id` field can be set inside the statement to create the record.

```surql
CREATE user SET id = rand::int(1, 1000000000);
```

## Field names

### Valid field names

Similar to record IDs, field names can be constructed from ASCII characters, underscores, and numbers:

```surql
--Query
CREATE user SET my_name_1 = 'name';

--Output
[
    {
        "id": "user:sklds4e7lqkewtddgijt",
        "my_name_1": "name"
    }
]
```

To create a field name with complex characters, use backticks:

```surql
--Query
CREATE user SET `mi_n√≥mineüòä` = 'name';

--Output
[
    {
        "id": "user:tkwse1j5o0anqjxonvzx",
        "mi_n√≥mineüòä": "name"
    }
]
```

Inside an object, non-ASCII field names can simply be set by using a string:

```surql
--Query
SELECT * FROM {
    "mi_n√≥mine": "name"
};

--Output
[
    {
        "mi_n√≥mine": "name"
    }
]
```

### Automatically generated field names

A field created from an operation will have a field name that represents the operation(s) used to construct it.

```surql
--Query
SELECT
    math::mean(temps),
    [ math::min(temps), math::max(temps) ]
FROM { temps: [-5, 8, 9] };

--Output
[
    {
        "[math::min(temps), math::max(temps)]": [
            -5,
            9
        ],
        "math::mean": 4
    }
]
```

Using `AS` allows these automatically calculated field names to be replaced with custom names:

```surql
--Query
SELECT
    math::mean(temps) AS mean_temps,
    [ math::min(temps), math::max(temps) ] AS avg_temps
FROM { temps: [-5, 8, 9] };

--Output
[
    {
        "avg_temps": [
            -5,
            9
        ],
        "mean_temps": 4
    }
]
```

### Auto-incrementing IDs

While SurrealDB does not use auto-incrementing IDs by default, this behaviour can be achieved in a number of ways. One is to use the [`record::id()`](/docs/surrealql/functions/database/record#recordid) function on the latest record, which returns the latter part of a record ID (the '1' in the record ID `person:1`). This can then be followed up with the [`type::thing()`](/docs/surrealql/functions/database/type#typething) function to create a new record ID.

```surql
-- Create records from person:1 to person:10
CREATE |person:1..10|;
LET $latest = SELECT VALUE id FROM ONLY person ORDER BY id DESC LIMIT 1;
CREATE type::thing("person", $latest.id() + 1);
```

```surql title="Output"
[
	{
		id: person:11
	}
]
```

When dealing with a large number of records, a more performant option is to use a separate record that holds a single value representing the latest ID. An [`UPSERT`](/docs/surrealql/statements/upsert) statement is best here, which will allow the counter to be initialized if it does not yet exist, and updated otherwise. This is best done [inside a manual transaction](/docs/surrealql/statements/begin) so that the latest ID will be rolled back if any failures occur when creating the next record.

```surql
BEGIN TRANSACTION;
UPSERT person_id:counter SET num += 1;
-- Creates a person:1
CREATE type::thing("person", person_id:counter.num);
COMMIT TRANSACTION;

BEGIN TRANSACTION;
-- Latest ID is now 2
UPSERT person_id:counter SET num += 1;
-- Whoops, invalid datetime format
-- Transaction fails and all changes are rolled back
CREATE type::thing("person", person_id:counter.num) SET created_at = <datetime>'2025_01+01';
COMMIT TRANSACTION;

-- Latest ID is still 1
RETURN person_id:counter.num;
```

## Defining record IDs in a schema

The type name of a record ID is `record`, which by default allows any sort of record. This type can be set inside a [`DEFINE FIELD`](/docs/surrealql/statements/define/field) statement.

```surql
DEFINE FIELD possessions ON TABLE person TYPE option<array<record>>;
DEFINE FIELD friends ON TABLE person TYPE option<array<record<person>>>;

CREATE person SET
    possessions = [ book:one, house:one],
    friends = [ person:one, person:two ];
```

Be sure to use just `record` instead of `record<any>`, as `<any>` here would imply actual records of a table called `any`.

```surql
DEFINE FIELD possessions ON TABLE person TYPE option<array<record<any>>>;

-- Won't work, 'book' and 'house' are not of table 'any'
CREATE person SET
    possessions = [ book:one, house:one ];

-- Actually expects this, which is probably
-- not what the DEFINE FIELD intended
CREATE person SET
    possessions = [ any:one, any:two ];
```

## Learn more

Learn more about Record IDs [in this blogpost](/blog/the-life-changing-magic-of-surrealdb-record-ids#the-performance-at-scale) and on this [youtube video](https://www.youtube.com/watch?v=c0cqmWRYP8c).
