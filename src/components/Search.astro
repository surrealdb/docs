---
import { Icon } from 'astro-icon/components';
---

<style>
    search-dialog :global(.docs-search-result) {
        @apply block px-6 py-4 hover:bg-bwr/10;

        & :global(h3) {
            @apply text-2xl;
        }

        & :global(span) {
            @apply text-surreal-pink text-xs pb-1 block;
        }

        & :global(p) {
            @apply text-text/80 font-thin text-sm;

            & :global(span) {
                @apply text-text/100;
            }
        }
    }

    search-dialog :global(.docs-search-message) {
        @apply w-full h-full flex items-center justify-center text-lg text-text/50;
    }

	search-dialog :global(.loader) {
		width: 24px;
		height: 24px;
		border-radius: 50%;
		position: relative;
		animation: rotate 0.5s linear infinite;
    }

	search-dialog :global(.loader)::before {
		content: "";
		box-sizing: border-box;
		position: absolute;
		inset: 0px;
		border-radius: 50%;
		border: 3px solid;
		animation: prixClipFix 1s linear infinite alternate-reverse;

		@apply border-surreal-pink
	}

    @keyframes rotate {
		100%   {transform: rotate(360deg)}
    }

    @keyframes prixClipFix {
        0%   {clip-path:polygon(50% 50%,0 0,0 0,0 0,0 0,0 0)}
        25%  {clip-path:polygon(50% 50%,0 0,100% 0,100% 0,100% 0,100% 0)}
        50%  {clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,100% 100%,100% 100%)}
        75%  {clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,0 100%,0 100%)}
        100% {clip-path:polygon(50% 50%,0 0,100% 0,100% 100%,0 100%,0 0)}
    }
</style>

<search-dialog>
    <button class="search-trigger flex items-center justify-between gap-6 bg-code rounded-lg border border-border w-full text-sm text-text/80 font-light py-2 px-3">
        <div class="flex items-center gap-2">
            <Icon name="fa6-solid:magnifying-glass" class="w-4 h-4" />
            Search the docs
        </div>
        <span class="bg-background/30 py-0.5 px-2 text-[0.6rem] font-mono rounded text-text">
            /
        </span>
    </button>
    <dialog class="fixed top-0 right-0 bottom-0 left-0 m-auto w-[900px] h-[700px] bg-background-secondary rounded-xl border-border border text-bwr outline-none backdrop:bg-background/50 backdrop:backdrop-blur-md transition-all">
        <div class="dialog-content h-full w-full flex flex-col">
            <div class="border-border border-b flex gap-4 items-center px-6 ">
				<Icon name="fa6-solid:magnifying-glass" class="w-4 h-4" />
				<input class="bg-background-secondary py-5 outline-none text-lg flex-1" placeholder="Search the docs" />
				<span class="loader"></span>
			</div>
            <div class="search-results relative flex-grow overflow-y-auto">
                <p class="docs-search-message">
                    Enter a search query
                </p>
            </div>
        </div>
    </dialog>
</search-dialog>

<script>
    class Search extends HTMLElement {
		#keybindHandler!: (e: KeyboardEvent) => void;

        connectedCallback() {
            const trigger = this.querySelector('.search-trigger');
            const input = this.querySelector('input');
            const dialog = this.querySelector('dialog');
            const dialogContent = this.querySelector('dialog .dialog-content');
            const searchResults = this.querySelector('dialog .search-results');
			const loader = this.querySelector<HTMLSpanElement>('.loader');
            if (!trigger || !dialog || !dialogContent || !searchResults || !input || !loader) throw new Error("Search element is broken")

			loader.style.display = "none";

            trigger.addEventListener('click', () => {
                dialog.showModal()
            });

            dialog.addEventListener('click', () => {
                dialog.close()
            });

            dialogContent.addEventListener('click', (e) => {
                e.stopPropagation();
            });

			this.#keybindHandler = this.handleKeybind.bind(this);
			document.addEventListener('keydown', this.#keybindHandler);

            function setMessage(message: string) {
                const el = document.createElement("p");
                el.classList.add("docs-search-message");
                el.innerText = message;
                searchResults!.innerHTML = "";
                searchResults!.appendChild(el);
            }

            let timeout: unknown;
            input.addEventListener('input', () => {
                if (timeout) clearTimeout(timeout as number);
                timeout = setTimeout(async () => {
                    if (input.value.length === 0) {
                        setMessage("Enter a search query");
                    } else {
						loader.style.display = "block";
                        const results = await search(input.value);
						loader.style.display = "none";
                        searchResults.innerHTML = "";
                        if (results.length > 0) {
                            for (const result of results) {
                                const rendered = createResult(result);
                                searchResults.appendChild(rendered);
                            }
                        } else {
                            setMessage("No results found");
                        }
                    }
                }, 300);
            });
        }

		disconnectedCallback() {
			document.removeEventListener('keydown', this.#keybindHandler);
		}

		handleKeybind(e: KeyboardEvent) {
			if (e.target instanceof HTMLInputElement || e.target instanceof HTMLTextAreaElement) return;

			if (e.key === '/') {
				e.preventDefault();
				const trigger = this.querySelector<HTMLDivElement>('.search-trigger');
				if (trigger) {
					trigger.click();
				}
			}
		}

    }

    customElements.define('search-dialog', Search);

    interface Offset {
    	e: number;
    	s: number;
    }

    interface Chunks {
    	bold: boolean;
    	value: string;
    }

    export interface Doc {
    	url: string;
    	title: string;
    	content: string[];
    	offsets: Record<number, Offset[]>;
    	score: number;
    	hostname: string;
    	chunks?: Chunks[];
    }

    export async function search(keywords: string): Promise<Doc[]> {
        const sql = templatedQuery(keywords);
        const docs = await query(sql);
    	const hostname = getHostname();
        const processed = docs
            .filter((match) => {
			return match.offsets
			&& match.hostname == hostname
			// && validateUrl(match.url, version)
		})
            .map(processResult);
      	return processed as Doc[];
    }

    function getHostname() {
    	const mapped: Record<string, string> = {
    		'surrealdb.com': 'main--surrealdb-docs.netlify.app',
    		'www.surrealdb.com': 'main--surrealdb-docs.netlify.app',
    		'docs.surrealdb.com': 'main--surrealdb-docs.netlify.app',
    		'surrealdb-docs.netlify.app': 'main--surrealdb-docs.netlify.app',
    		'localhost': 'main--surrealdb-docs.netlify.app',
    	};

    	return mapped[location.hostname] || location.hostname;
    }

    const templatedQuery = (keywords: string) => {
    	const escaped = JSON.stringify(keywords);
    	const hostname = JSON.stringify(getHostname());
    	return /* surrealql */ `
    		LET $escaped = ${escaped};
    		SELECT
    			path as url,
    			hostname,
    			title,
    			content,
    			search::offsets(7) AS offsets,
    			(
    				  (search::score(0) * 10)
    				+ (search::score(1) * 9)
    				+ (search::score(2) * 7)
    				+ (search::score(3) * 6)
    				+ (search::score(4) * 5)
    				+ (search::score(5) * 4)
    				+ (search::score(6) * 2)
    				+ search::score(7)
    			) AS score
    		FROM page
    			WHERE
    				hostname = ${hostname}
    				AND (
    					title @0@ $escaped
    					OR path @1@ $escaped
    					OR h1 @2@ $escaped
    					OR h2 @3@ $escaped
    					OR h3 @4@ $escaped
    					OR h4 @5@ $escaped
    					OR code @6@ $escaped
    					OR content @7@ $escaped
    				)
    		ORDER BY score DESC LIMIT 10;
    	`;
	};

	async function query(sql: string) {
		const raw = await fetch('https://blog-db.surrealdb.com/sql', {
			method: 'POST',
			headers: {
				Accept: 'application/json',
			},
			body: `USE NS docs DB search; ${sql}`,
		});
		const json = (await raw.json()).slice(1);
		const result: Doc[] = json[1].result ?? []
		return result;
	}

    function processResult(doc: Doc) {
    	// Will:
    	// - group offsets per line (see groupOffsets() function)
    	// - Sort descending based on the length of the offsets
    	// - pick the biggest offset
    	let maxOffsetSize = -1;
    	let linenumber = null;
    	let offsets = null;

    	for (const [line, off] of Object.entries(doc.offsets)) {
            const currentOffsetSize = findBiggestOffsets(off);
    		if (currentOffsetSize > maxOffsetSize) {
    			maxOffsetSize = currentOffsetSize;
    			linenumber = line;
    			offsets = off;
    		}
    	}

    	// - Grab the actual content of the line.
    	// - Split up in chunks of what to highlight and what not.
    	const line = doc.content[Number(linenumber)];
    	const chunks = (offsets ?? [])
    		.flatMap(({ s, e }, i, arr) => {
    			const next = arr[i + 1];
    			return [
    				i == 0 && { bold: false, value: line.slice(0, s) },
    				{ bold: true, value: line.slice(s, e) },
    				{ bold: false, value: line.slice(e, next?.s) },
    			];
    		})
    		.filter((a) => a);

    	return {
    		...doc,
    		chunks,
    	};
    }

    function findBiggestOffsets(offsets: Offset[]) {
        return offsets.reduce((sum, { s, e }) => sum + (e - s), 0);
    }

    function createResult(
        doc: Doc
    ): HTMLElement {
        const result = document.createElement("a");
        result.href = doc.url;
        result.classList.add("docs-search-result");

        const title = document.createElement("h3");
        title.innerText = doc.title;
        result.appendChild(title);

        const link = document.createElement("span");
        link.innerText = doc.url;
        result.appendChild(link);

        const match = document.createElement("p");
        for (const chunk of doc.chunks ?? []) {
            if (chunk.bold) {
                const node = document.createElement("b");
                node.innerText = chunk.value;
                match.appendChild(node);
            } else {
                const node = document.createTextNode(chunk.value);
                match.appendChild(node);
            }
        }
        result.appendChild(match);

        return result;
    }
</script>
