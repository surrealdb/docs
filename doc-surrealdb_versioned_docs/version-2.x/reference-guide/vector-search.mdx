---
sidebar_position: 3
sidebar_label: Vector Search
title: Vector Search | Reference guides
description: Vector Search in SurrealDB is introduced to support efficient and accurate searching of high-dimensional data. This guide covers the essentials of working with vectors in SurrealDB, from storing vectors in embeddings to performing computations and optimising searches with different indexing strategies.
---

# Vector Search

SurrealDB supports [Full-Text Search](/docs/surrealdb/2.x/reference-guide/full-text-search) and [Vector Search](https://www.youtube.com/watch?v=MqddPmgKSCs). Full-text search(FTS) involves indexing documents using the FTS index and breaking down the content of the document into smaller tokens with the help of [analysers](/docs/surrealdb/2.x/surrealql/statements/define/analyzer) and [tokenizers](/docs/surrealdb/2.x/surrealql/statements/define/analyzer#tokenizers). 
Vector Search in SurrealDB is introduced to support efficient and accurate searching of high-dimensional data. This guide covers the essentials of working with vectors in SurrealDB, from storing vectors in embeddings to performing computations and optimising searches with different indexing strategies.

## What is Vector Search

Vector search is a search mechanism that goes beyond traditional keyword matching and text-based search methods to capture deeper characteristics and similarities between data. 

It converts data such as text, images, or sounds into numerical vectors, called vector embeddings.

You can think of Vector embeddings as cells. Like how cells form the basic structural and biological unit of all known living organisms, vector embeddings serve as the basic units of data representation in vector search. 

Vector Search isn't new to the world of data science. [Gerard Salton](https://en.wikipedia.org/wiki/Gerard_Salton), known as the Father of Information Retrieval, introduced the Vector Space Model, cosine similarity, and TF-IDF  for information retrieval around 1960. 

If you’re interested in understanding Vector Search in depth, I recommend reading academic papers like Sebastian Bruch's on [Vector Retrieval](https://arxiv.org/abs/2401.09350). 

## Vector Search vs Full-Text Search

You might be familiar with our [Reference Guide for Full-Text Search](/docs/surrealdb/2.x/reference-guide/full-text-search), but you might wonder how it differs from Vector Search. Let's consider an example:
Below is a screenshot of a Google search for the word “Lead”. The search has pulled up different definitions of the word “Lead”. 

Lead can mean `taking initiative`, as well as the chemical element with the symbol `Pb`. 

![lead.png](Vector%20Search%2084d78ae89e5540c1b0269c016317e036/lead.png)

Now let’s add some context to the word. 
Consider a database of liquids samples which note down harmful chemicals that are found in them. 

```surql
INSERT INTO liquids [
    {sample:'Sea water', content: 'The sea water contains some amount of lead'},
    {sample:'Tap water', content: 'The team lead by Dr. Rose found out that the tap water in was potable'},
    {sample:'Sewage water', content: 'High amounts of a were found in Sewage water'}
]
```

A `select` statement to retrieve all the samples that contain the chemical `lead` will bring up all the samples which have the word `lead` mentioned in it.

```surql
SELECT
  sample,
  content
FROM liquids
WHERE content @0@ 'lead';
```

```surql
[
	{
		content: 'The team lead by Dr. Rose found out that the tap water in was potable',
		sample: 'Tap water'
	},
	{
		content: 'The sea water contains some amount of lead',
		sample: 'Sea water'
	}
]
```

If you read through the content of the tap water sample, you’ll notice that it does not contain any lead in it but it has the mention of the word `lead` under “The team lead by Dr. Rose…” which means that the team was guided by Dr. Rose. The search pulled up both the records although the tap water sample had no lead in it. This example shows us that while [Full-Text Search](/docs/surrealdb/2.x/reference-guide/full-text-search) does a great job at matching query terms with indexed documents, it may not be the best solution for use cases where the query terms have deeper context and scope for ambiguity. 

## Vector Search in SurrealDB

![Vector Search in SurrealDB](cpesm8bpt70c73f6h3e0)

The Vector Search feature of SurrealDB will help you do more and dig deeper into your data. 
Vector Search works quite differently from [Full-Text Search](https://surrealdb.com/blog/create-a-search-engine-with-surrealdb-full-text-search). 

While you can use it for the same use case ( searching ), Vector search goes beyond the basic expectations of search.

For example, if you wanted to search for an actor or actress who looked like you from an extensive dataset of movie artists, you would first use an ML model to convert the artist's images and details into vector embeddings and then use SurrealQL to find the artist with the most resemblance to your face vector embeddings. The more characteristics you decide to include in your vector embeddings, the higher the dimensionality of your vector will be, potentially improving the accuracy of the matches but also increasing the complexity of the vector search.

```surql
CREATE actor:1 SET name = 'Actor 1', embedding = [0.1, 0.2, 0.3, 0.4];
CREATE actor:2 SET name = 'Actor 2', embedding = [0.2, 0.1, 0.4, 0.3];
CREATE actor:3 SET name = 'Actor 3', embedding = [0.4, 0.3, 0.2, 0.1];
CREATE actor:4 SET name = 'Actor 4', embedding = [0.3, 0.4, 0.1, 0.2];
```

Output:
```surql
[[{ embedding: [0.1f, 0.2f, 0.3f, 0.4f], id: actor:1, name: 'Actor 1' }], 
[{ embedding: [0.2f, 0.1f, 0.4f, 0.3f], id: actor:2, name: 'Actor 2' }], 
[{ embedding: [0.4f, 0.3f, 0.2f, 0.1f], id: actor:3, name: 'Actor 3' }], 
[{ embedding: [0.3f, 0.4f, 0.1f, 0.2f], id: actor:4, name: 'Actor 4' }]]
```

You can assume your facial features to be

```surql
LET $person_embedding = [0.15, 0.25, 0.35, 0.45];
```

In this case, you have the option of using 3 different approaches. 

- [Bruteforce](/docs/surrealdb/2.x/surrealql/operators#brute-force-method-since-130)
- [Hierarchical navigable small world(HNSW)](/docs/surrealdb/2.x/surrealql/statements/define/indexes#hnsw-hierarchical-navigable-small-world-since-150)
- [M-Tree](/docs/surrealdb/2.x/surrealql/statements/define/indexes#m-tree-index-since-130)

As you want to perform a nearest neighbour search and not an exact search, you would typically use an index like [HNSW](/docs/surrealdb/2.x/surrealql/statements/define/indexes#hnsw-hierarchical-navigable-small-world-since-150) or [M-Tree](/docs/surrealdb/2.x/surrealql/statements/define/indexes#m-tree-index-since-130). 

```surql
DEFINE INDEX mt_pts ON actor FIELDS embedding MTREE DIMENSION 4 TYPE F32;
SELECT id, name, vector::similarity::cosine(embedding, $person_embedding) AS dist FROM actor WHERE embedding <|2|> $person_embedding;
SELECT id, vector::distance::euclidean(embedding, $person_embedding) AS dist FROM actor WHERE embedding <|1|> $person_embedding;
```

Output:
```surql
[[{ dist: 0.9979654098963515f, id: actor:1, name: 'Actor 1' }, 
{ dist: 0.9409388150451313f, id: actor:2, name: 'Actor 2' }]]
```

Now that you know how to draft a vector search query in SurrealQL, let's take a step back and understand some of its terms and concepts. 

## How to store vector embeddings

To store vectors in SurrealDB, you typically define a field within your data schema dedicated to holding the vector data. These vectors represent space data points and can be used for various applications, from recommendation systems to image recognition. Below is an example of how to create records with vector embeddings:

```surql
CREATE Document:1 CONTENT {
  "items": [
    {
      "content": "apple",
      "embedding": [0.00995, -0.02680, -0.01881, -0.08697]
    }
  ]
};
```

The vector is represented as an array of floating-point numbers.

There are no strict rules or limitations regarding the length of the embeddings, and they can be as large as needed. Just keep in mind that larger embeddings lead to more data to process and that can affect performance and query times based on your physical hardware.

## Computation on Vectors: "vector::" Package of Functions

SurrealDB provides [Vector Functions](/docs/surrealdb/2.x/surrealql/database/functions/vector) for most of the major numerical computations done on vectors. They include functions for element-wise addition, division and even normalisation. 

They also include similarity and distance functions, which help in understanding how similar or dissimilar two vector vectors are. 
Usually, the vector with the smallest distance or the largest cosine similarity value (closest to 1) is deemed the most similar to the item you are trying to search for. 

![Distance and Similarity functions](Add code here)

The choice of distance or similarity function depends on the nature of your data and the specific requirements of your application.

In the previous example of actors' facial data, we assumed that the embeddings represented the facial characteristics. We used the `vector::similarity::cosine` function because cosine similarity is typically preferred when absolute distances are less important, but proportions and direction matter more. 
This means that, in our use case, we are less concerned with two noses being the same size and more interested in two faces having similar proportions.
As cosine similarity measures the orientation of the vectors, rather than their absolute magnitudes, this makes it suitable to help capture the overall similarity in facial features and proportions, while being less sensitive to factors like scale or image brightness.

Now, if your embeddings represented the actors’ careers, their awards, and their box office revenue, and we were trying to find who was the most successful actor after you or your favorite actor, using Euclidean distance would make more sense. 

```surql
SELECT id, vector::distance::euclidean(embedding, $person_embedding) AS dist FROM actor WHERE embedding <|1|> $person_embedding;
```

## Vector Indexes

When it comes to search, you can always do it using brute force. 
In SurrealDB, you can use the [Brute force approach](/docs/surrealdb/2.x/surrealql/statements/define/indexes#brute-force-method) to search through your vector embeddings and data. 

Brute force search compares a query vector against all vectors in the dataset to find the closest match. As this is a brute-force approach, you do not create an index for this approach. 

The brute force approach for finding the nearest neighbour is generally preferred in the following use cases:

- Small Datasets / Limited Query vectors: For applications with small datasets, the overhead of building and maintaining an index might outweigh its benefits. In such cases, the brute force approach is optimal.
- Guaranteed Accuracy: Since the brute force method compares the query vector against every vector in the dataset, it guarantees finding the exact nearest vectors based on the chosen distance metric (like Euclidean, Manhattan, etc.).
- Benchmarking Models: The Brute force approach can be used as a reference, and help benchmark the performance of other approximate alternatives like HNSW

While brute force can give you exact results, it's computationally expensive for large datasets. 

In most cases, you do not need a 100% exact match, and you can give it up for faster, high-dimensional searches to find the approximate nearest neighbour to a query vector. 

This is where Vector indexes come in. 

In SurrealDB, you can perform a vector search using the two primary indexes:

1. M-Tree Index:
    - The [M-Tree index](/docs/surrealdb/2.x/surrealql/statements/define/indexes#m-tree-index-since-130) is a metric tree-based index suitable for similarity search in metric spaces.
    - The M-Tree index can be configured with parameters such as the distance function to compare the vectors.
2. Hierarchical Navigable Small World (HNSW) Index:
    - [HNSW](https://en.wikipedia.org/wiki/Hierarchical_navigable_small_world) (Hierarchical Navigable Small World) is a state-of-the-art algorithm for approximate nearest neighbour search in high-dimensional spaces. It offers a balance between search efficiency and accuracy.
    - The [HNSW index](/docs/surrealdb/2.x/surrealql/statements/define/indexes#hnsw-hierarchical-navigable-small-world-since-150) is a proximity graph-based index.

By design, HNSW currently operates as an 'in-memory' structure. Introducing persistence to this feature, while beneficial for retaining index states, is an ongoing area of development. Our goal is to balance the speed of data ingestion with the advantages of persistence. You can also use the  [`REBUILD` statement](/docs/surrealdb/2.x/surrealql/statements/rebuild), which allows for the manual rebuilding of indexes as needed. This approach ensures that while we explore persistence options, we maintain the optimal performance that users expect from HNSW and MTree, providing flexibility and control over the indexing process.

Both indexes are designed to handle the challenges of searching in spaces where traditional indexing methods become inefficient. The choice between HNSW and M-Tree would depend on the application's specific requirements, such as the need for an exact versus approximate nearest neighbour search, the distance metric used, and the nature of the data.

## Filtering through Vector Search

The `vector::distance::knn()` function from SurrealDB returns the distance computed between vectors by the KNN operator. This operator can be used to avoid recomputation of the distance in every `select` query. 

Consider a scenario where you’re searching for actors who look like you but they should have won an Oscar. You set a flag, which is true for actors who’ve won the golden trophy. 

Let’s update our dataset with flags and define an HNSW index on the embeddings field. 

```surql
UPDATE actor:1 SET flag = true;
UPDATE actor:2 SET flag = false;
UPDATE actor:3 SET flag = true;
UPDATE actor:4 SET flag = true;
DEFINE INDEX hnsw_pts ON actor FIELDS embedding HNSW DIMENSION 4
```

Use the following query to find actors who match the criteria:

```surql
SELECT id, flag, vector::distance::knn() AS distance FROM actor WHERE flag = true AND embedding <|2,40|> $person_embedding ORDER BY distance;
```

```surql
[
	[
		{
			distance: 0.09999999999999998f,
			flag: true,
			id: actor:1
		},
		{
			distance: 0.412310562561766f,
			flag: true,
			id: actor:4
		}
	]
];
```

`actor:1` and `actor:2` have the closest resemblance with your query vector and also have won an Oscar.

## Conclusion

Vector Search does not need to be complicated and overwhelming. Once you have your embeddings available, you can try out different vector functions in combination with your query vector to see what works best for your use case. As discussed in the reference guide, you have 3 options to perform Vector Search in SurrealDB. Based on the complexity of your data and accuracy expectations, you can choose between them. You can design your `select` statements to query your search results along with filters and conditions. In order to avoid recalculation of the KNN distance for every single query, you also have the `vector::distance::knn()`
Due to GenAI, most applications today deal with intricate data with layered meanings and characteristics. Vector search plays a big role in analyzing such data to find what you’re looking for or to make informed decisions.

You can start using Vector Search in SurrealDB by [installing SurrealDB](https://surrealdb.com/install) on your machines or by using [Surrealist](https://surrealdb.com/surrealist). And if you’re looking for a [quick video explaining Vector Search](https://www.youtube.com/watch?v=MqddPmgKSCs), check out our [YouTube channel](https://www.youtube.com/@SurrealDB).